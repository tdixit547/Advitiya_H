{"file":"/Users/grover.heer/Documents/GitHub/Advitiya_H/src/services/DecisionTreeEngine.ts","mappings":"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","names":[],"sources":["/Users/grover.heer/Documents/GitHub/Advitiya_H/src/services/DecisionTreeEngine.ts"],"sourcesContent":["import UAParser from 'ua-parser-js';\nimport { DateTime } from 'luxon';\nimport * as geolib from 'geolib';\nimport { IDecisionNode, ITimeWindow, IGeoPolygon, IRadiusFallback } from '../models/RuleTree';\n\n/**\n * Request context for decision tree traversal\n */\nexport interface IRequestContext {\n    userAgent: string;\n    country: string;\n    lat: number;\n    lon: number;\n    timestamp: Date;\n}\n\n/**\n * Parsed device information\n */\nexport interface IDeviceInfo {\n    type: string;          // \"mobile\" | \"desktop\" | \"tablet\" | \"other\"\n    browser: string;\n    os: string;\n}\n\n/**\n * Decision Tree Engine\n * Evaluates requests against a rule tree in strict order: device → location → time\n */\nexport class DecisionTreeEngine {\n\n    /**\n     * Main traversal entry point\n     * Returns variant IDs from the reached leaf node\n     */\n    traverse(context: IRequestContext, root: IDecisionNode): string[] {\n        let currentNode: IDecisionNode | undefined = root;\n\n        // Traverse until we reach a leaf\n        while (currentNode && currentNode.type !== 'leaf') {\n            switch (currentNode.type) {\n                case 'device':\n                    currentNode = this.evaluateDeviceNode(context.userAgent, currentNode);\n                    break;\n                case 'location':\n                    currentNode = this.evaluateLocationNode(\n                        context.country,\n                        context.lat,\n                        context.lon,\n                        currentNode\n                    );\n                    break;\n                case 'time':\n                    currentNode = this.evaluateTimeNode(context.timestamp, currentNode);\n                    break;\n                default:\n                    // Unknown node type, return empty\n                    return [];\n            }\n        }\n\n        // Return variant IDs from leaf or empty array\n        return currentNode?.variant_ids || [];\n    }\n\n    /**\n     * Parse user agent to determine device type\n     */\n    parseDevice(userAgent: string): IDeviceInfo {\n        const parser = new UAParser(userAgent);\n        const result = parser.getResult();\n\n        let type = 'other';\n        const deviceType = result.device?.type;\n\n        if (deviceType === 'mobile') {\n            type = 'mobile';\n        } else if (deviceType === 'tablet') {\n            type = 'tablet';\n        } else if (!deviceType || deviceType === 'undefined') {\n            // No device type usually means desktop browser\n            type = 'desktop';\n        }\n\n        return {\n            type,\n            browser: result.browser?.name || 'unknown',\n            os: result.os?.name || 'unknown',\n        };\n    }\n\n    /**\n     * Evaluate device node\n     * Branches: mobile, desktop, tablet, default\n     */\n    private evaluateDeviceNode(userAgent: string, node: IDecisionNode): IDecisionNode | undefined {\n        const deviceInfo = this.parseDevice(userAgent);\n        const branches = node.device_branches;\n\n        if (!branches) {\n            return undefined;\n        }\n\n        // Convert Map to object if needed (MongoDB returns Map)\n        const branchesObj = branches instanceof Map\n            ? Object.fromEntries(branches)\n            : branches;\n\n        // Try exact match first\n        if (branchesObj[deviceInfo.type]) {\n            return branchesObj[deviceInfo.type] as IDecisionNode;\n        }\n\n        // Fall back to default\n        if (branchesObj['default']) {\n            return branchesObj['default'] as IDecisionNode;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Evaluate location node\n     * Priority: country code → polygon contains → radius check → default\n     */\n    private evaluateLocationNode(\n        country: string,\n        lat: number,\n        lon: number,\n        node: IDecisionNode\n    ): IDecisionNode | undefined {\n        const countryBranches = node.country_branches;\n\n        // Convert Map to object if needed\n        const branchesObj = countryBranches instanceof Map\n            ? Object.fromEntries(countryBranches)\n            : countryBranches;\n\n        // 1. Try country code match\n        if (branchesObj && branchesObj[country.toUpperCase()]) {\n            return branchesObj[country.toUpperCase()] as IDecisionNode;\n        }\n\n        // 2. Try polygon containment check\n        if (node.polygon_fallback && node.polygon_fallback_node) {\n            if (this.isPointInPolygon(lat, lon, node.polygon_fallback)) {\n                return node.polygon_fallback_node;\n            }\n        }\n\n        // 3. Try radius check\n        if (node.radius_fallback && node.radius_fallback_node) {\n            if (this.isPointInRadius(lat, lon, node.radius_fallback)) {\n                return node.radius_fallback_node;\n            }\n        }\n\n        // 4. Fall back to default\n        if (node.location_default_node) {\n            return node.location_default_node;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Check if a point is inside a GeoJSON polygon\n     */\n    private isPointInPolygon(lat: number, lon: number, polygon: IGeoPolygon): boolean {\n        if (!polygon.coordinates || polygon.coordinates.length === 0) {\n            return false;\n        }\n\n        // Convert GeoJSON coordinates (lon, lat) to geolib format\n        const ring = polygon.coordinates[0];\n        const geolibPolygon = ring.map(([lng, lt]) => ({ latitude: lt, longitude: lng }));\n\n        return geolib.isPointInPolygon(\n            { latitude: lat, longitude: lon },\n            geolibPolygon\n        );\n    }\n\n    /**\n     * Check if a point is within a radius of a center point\n     */\n    private isPointInRadius(lat: number, lon: number, radius: IRadiusFallback): boolean {\n        const [centerLat, centerLon] = radius.center;\n\n        const distance = geolib.getDistance(\n            { latitude: lat, longitude: lon },\n            { latitude: centerLat, longitude: centerLon }\n        );\n\n        // Convert km to meters for comparison\n        return distance <= radius.radius_km * 1000;\n    }\n\n    /**\n     * Evaluate time node\n     * Checks recurring windows (day + time in timezone) then absolute windows\n     */\n    private evaluateTimeNode(timestamp: Date, node: IDecisionNode): IDecisionNode | undefined {\n        const timeWindows = node.time_windows;\n\n        if (!timeWindows || timeWindows.length === 0) {\n            return node.time_default_node;\n        }\n\n        // Check each time window in order\n        for (const window of timeWindows) {\n            if (this.isInTimeWindow(timestamp, window)) {\n                return window.next_node;\n            }\n        }\n\n        // Fall back to default\n        return node.time_default_node;\n    }\n\n    /**\n     * Check if timestamp falls within a time window\n     */\n    private isInTimeWindow(timestamp: Date, window: ITimeWindow & { next_node: IDecisionNode }): boolean {\n        // Check recurring windows first\n        if (window.recurring) {\n            const { days, start_time, end_time, timezone } = window.recurring;\n\n            // Convert timestamp to the specified timezone\n            const dt = DateTime.fromJSDate(timestamp).setZone(timezone);\n            const currentDay = dt.weekday % 7; // Luxon uses 1-7 (Mon-Sun), convert to 0-6 (Sun-Sat)\n\n            // Check if current day matches\n            if (!days.includes(currentDay)) {\n                return false;\n            }\n\n            // Parse start and end times\n            const [startHour, startMin] = start_time.split(':').map(Number);\n            const [endHour, endMin] = end_time.split(':').map(Number);\n\n            const currentMinutes = dt.hour * 60 + dt.minute;\n            const startMinutes = startHour * 60 + startMin;\n            const endMinutes = endHour * 60 + endMin;\n\n            // Handle overnight windows (e.g., 22:00 - 06:00)\n            if (startMinutes <= endMinutes) {\n                return currentMinutes >= startMinutes && currentMinutes <= endMinutes;\n            } else {\n                return currentMinutes >= startMinutes || currentMinutes <= endMinutes;\n            }\n        }\n\n        // Check absolute windows\n        if (window.absolute) {\n            const { start, end } = window.absolute;\n            const ts = timestamp.getTime();\n            return ts >= new Date(start).getTime() && ts <= new Date(end).getTime();\n        }\n\n        return false;\n    }\n}\n\n// Singleton instance\nexport const decisionTreeEngine = new DecisionTreeEngine();\n"],"version":3}