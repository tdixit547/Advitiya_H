{"file":"/Users/grover.heer/Documents/GitHub/Advitiya_H/src/services/VariantResolver.ts","mappings":";;;AAAA,+CAAsD;AACtD,yDAAqE;AAUrE;;;;;;GAMG;AACH,MAAa,eAAe;IAExB;;OAEG;IACH,KAAK,CAAC,cAAc,CAAC,UAAoB,EAAE,KAAa;QACpD,IAAI,CAAC,UAAU,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzC,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,iCAAiC;QACjC,MAAM,QAAQ,GAAG,MAAM,iBAAO,CAAC,IAAI,CAAC;YAChC,UAAU,EAAE,EAAE,GAAG,EAAE,UAAU,EAAE;YAC/B,MAAM,EAAE,KAAK;YACb,OAAO,EAAE,IAAI;SAChB,CAAC,CAAC;QAEH,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,0CAA0C;QAC1C,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC;QACvB,CAAC;QAED,+BAA+B;QAC/B,MAAM,KAAK,GAAG,MAAM,2BAAY,CAAC,IAAI,CAAC;YAClC,UAAU,EAAE,EAAE,GAAG,EAAE,UAAU,EAAE;YAC/B,MAAM,EAAE,KAAK;SAChB,CAAC,CAAC;QAEH,sCAAsC;QACtC,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAyB,CAAC;QAClD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACvB,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QACxC,CAAC;QAED,oCAAoC;QACpC,MAAM,iBAAiB,GAAwB,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;YACtE,OAAO;YACP,KAAK,EAAE,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,IAAI;SAClD,CAAC,CAAC,CAAC;QAEJ,6CAA6C;QAC7C,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YAC5B,MAAM,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC;YACnC,MAAM,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC;YAEnC,yBAAyB;YACzB,IAAI,MAAM,KAAK,MAAM,EAAE,CAAC;gBACpB,OAAO,MAAM,GAAG,MAAM,CAAC;YAC3B,CAAC;YAED,mBAAmB;YACnB,OAAO,CAAC,CAAC,OAAO,CAAC,QAAQ,GAAG,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnD,CAAC,CAAC,CAAC;QAEH,qCAAqC;QACrC,MAAM,QAAQ,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC;QACxD,MAAM,WAAW,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC;QAE1D,MAAM,IAAI,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE;YACxC,MAAM,KAAK,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC;YAClC,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,KAAK,WAAW,CAAC;QACpE,CAAC,CAAC,CAAC;QAEH,mDAAmD;QACnD,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAClB,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QAC3D,CAAC;QAED,yBAAyB;QACzB,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;IACxC,CAAC;IAED;;OAEG;IACH,cAAc,CAAC,QAAoB;QAC/B,yBAAyB;QACzB,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QAEnE,2CAA2C;QAC3C,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;YACpB,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;QACjE,CAAC;QAED,gDAAgD;QAChD,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,WAAW,CAAC;QAEzC,qDAAqD;QACrD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;YAC7B,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC;YACzB,IAAI,MAAM,IAAI,CAAC,EAAE,CAAC;gBACd,OAAO,OAAO,CAAC;YACnB,CAAC;QACL,CAAC;QAED,8BAA8B;QAC9B,OAAO,QAAQ,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACzC,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,kBAAkB,CAAC,KAAa;QAClC,OAAO,iBAAO,CAAC,IAAI,CAAC;YAChB,MAAM,EAAE,KAAK;YACb,OAAO,EAAE,IAAI;SAChB,CAAC,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,UAAU,CAAC,SAAiB;QAC9B,OAAO,iBAAO,CAAC,OAAO,CAAC,EAAE,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC;IACtD,CAAC;CACJ;AAvHD,0CAuHC;AAED,qBAAqB;AACR,QAAA,eAAe,GAAG,IAAI,eAAe,EAAE,CAAC","names":[],"sources":["/Users/grover.heer/Documents/GitHub/Advitiya_H/src/services/VariantResolver.ts"],"sourcesContent":["import { Variant, IVariant } from '../models/Variant';\nimport { VariantStats, IVariantStats } from '../models/VariantStats';\n\n/**\n * Variant with its stats for resolution\n */\ninterface IVariantWithStats {\n    variant: IVariant;\n    stats: IVariantStats | null;\n}\n\n/**\n * Variant Resolver\n * Resolves which variant to use based on:\n * 1. Score (precomputed from clicks, impressions, CTR)\n * 2. Priority (higher is better)\n * 3. Weighted random (for final ties)\n */\nexport class VariantResolver {\n\n    /**\n     * Resolve the best variant from a list of variant IDs\n     */\n    async resolveVariant(variantIds: string[], hubId: string): Promise<IVariant | null> {\n        if (!variantIds || variantIds.length === 0) {\n            return null;\n        }\n\n        // Fetch variants and their stats\n        const variants = await Variant.find({\n            variant_id: { $in: variantIds },\n            hub_id: hubId,\n            enabled: true,\n        });\n\n        if (variants.length === 0) {\n            return null;\n        }\n\n        // If only one variant, return it directly\n        if (variants.length === 1) {\n            return variants[0];\n        }\n\n        // Fetch stats for all variants\n        const stats = await VariantStats.find({\n            variant_id: { $in: variantIds },\n            hub_id: hubId,\n        });\n\n        // Create a map for quick stats lookup\n        const statsMap = new Map<string, IVariantStats>();\n        for (const stat of stats) {\n            statsMap.set(stat.variant_id, stat);\n        }\n\n        // Combine variants with their stats\n        const variantsWithStats: IVariantWithStats[] = variants.map((variant) => ({\n            variant,\n            stats: statsMap.get(variant.variant_id) || null,\n        }));\n\n        // Sort by score (desc), then priority (desc)\n        variantsWithStats.sort((a, b) => {\n            const scoreA = a.stats?.score || 0;\n            const scoreB = b.stats?.score || 0;\n\n            // First compare by score\n            if (scoreB !== scoreA) {\n                return scoreB - scoreA;\n            }\n\n            // Then by priority\n            return b.variant.priority - a.variant.priority;\n        });\n\n        // Check if there are ties at the top\n        const topScore = variantsWithStats[0].stats?.score || 0;\n        const topPriority = variantsWithStats[0].variant.priority;\n\n        const ties = variantsWithStats.filter((v) => {\n            const score = v.stats?.score || 0;\n            return score === topScore && v.variant.priority === topPriority;\n        });\n\n        // If there are ties, use weighted random selection\n        if (ties.length > 1) {\n            return this.weightedRandom(ties.map((t) => t.variant));\n        }\n\n        // Return the top variant\n        return variantsWithStats[0].variant;\n    }\n\n    /**\n     * Weighted random selection among tied variants\n     */\n    weightedRandom(variants: IVariant[]): IVariant {\n        // Calculate total weight\n        const totalWeight = variants.reduce((sum, v) => sum + v.weight, 0);\n\n        // Handle edge case where all weights are 0\n        if (totalWeight === 0) {\n            return variants[Math.floor(Math.random() * variants.length)];\n        }\n\n        // Pick a random value between 0 and totalWeight\n        let random = Math.random() * totalWeight;\n\n        // Find the variant that this random value falls into\n        for (const variant of variants) {\n            random -= variant.weight;\n            if (random <= 0) {\n                return variant;\n            }\n        }\n\n        // Fallback (shouldn't happen)\n        return variants[variants.length - 1];\n    }\n\n    /**\n     * Get all enabled variants for a hub\n     */\n    async getEnabledVariants(hubId: string): Promise<IVariant[]> {\n        return Variant.find({\n            hub_id: hubId,\n            enabled: true,\n        }).sort({ priority: -1 });\n    }\n\n    /**\n     * Get variant by ID\n     */\n    async getVariant(variantId: string): Promise<IVariant | null> {\n        return Variant.findOne({ variant_id: variantId });\n    }\n}\n\n// Singleton instance\nexport const variantResolver = new VariantResolver();\n"],"version":3}