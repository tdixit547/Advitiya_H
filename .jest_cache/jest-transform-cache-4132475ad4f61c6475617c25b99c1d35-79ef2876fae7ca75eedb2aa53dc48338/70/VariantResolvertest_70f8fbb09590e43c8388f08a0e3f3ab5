2e2f9eab414eda1087a782c0684ff74d
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Mock mongoose models
jest.mock('../models/Variant', () => ({
    Variant: {
        find: jest.fn(),
        findOne: jest.fn(),
    },
}));
jest.mock('../models/VariantStats', () => ({
    VariantStats: {
        find: jest.fn(),
    },
}));
const VariantResolver_1 = require("../services/VariantResolver");
const Variant_1 = require("../models/Variant");
const VariantStats_1 = require("../models/VariantStats");
describe('VariantResolver', () => {
    let resolver;
    beforeEach(() => {
        resolver = new VariantResolver_1.VariantResolver();
        jest.clearAllMocks();
    });
    describe('resolveVariant', () => {
        it('should return null for empty variant list', async () => {
            const result = await resolver.resolveVariant([], 'hub_001');
            expect(result).toBeNull();
        });
        it('should return variant directly if only one option', async () => {
            const mockVariant = {
                variant_id: 'var_1',
                hub_id: 'hub_001',
                target_url: 'https://example.com',
                priority: 10,
                weight: 1,
                enabled: true,
            };
            Variant_1.Variant.find.mockResolvedValue([mockVariant]);
            const result = await resolver.resolveVariant(['var_1'], 'hub_001');
            expect(result).toEqual(mockVariant);
        });
        it('should select variant with highest score', async () => {
            const variants = [
                { variant_id: 'var_1', hub_id: 'hub_001', target_url: 'url1', priority: 5, weight: 1 },
                { variant_id: 'var_2', hub_id: 'hub_001', target_url: 'url2', priority: 5, weight: 1 },
            ];
            const stats = [
                { variant_id: 'var_1', hub_id: 'hub_001', score: 0.5 },
                { variant_id: 'var_2', hub_id: 'hub_001', score: 0.8 }, // Higher score
            ];
            Variant_1.Variant.find.mockResolvedValue(variants);
            VariantStats_1.VariantStats.find.mockResolvedValue(stats);
            const result = await resolver.resolveVariant(['var_1', 'var_2'], 'hub_001');
            expect(result?.variant_id).toBe('var_2');
        });
        it('should break ties using priority', async () => {
            const variants = [
                { variant_id: 'var_1', hub_id: 'hub_001', target_url: 'url1', priority: 5, weight: 1 },
                { variant_id: 'var_2', hub_id: 'hub_001', target_url: 'url2', priority: 10, weight: 1 }, // Higher priority
            ];
            const stats = [
                { variant_id: 'var_1', hub_id: 'hub_001', score: 0.5 },
                { variant_id: 'var_2', hub_id: 'hub_001', score: 0.5 }, // Same score
            ];
            Variant_1.Variant.find.mockResolvedValue(variants);
            VariantStats_1.VariantStats.find.mockResolvedValue(stats);
            const result = await resolver.resolveVariant(['var_1', 'var_2'], 'hub_001');
            expect(result?.variant_id).toBe('var_2');
        });
    });
    describe('weightedRandom', () => {
        it('should select from variants based on weight', () => {
            const variants = [
                { variant_id: 'var_1', weight: 1 },
                { variant_id: 'var_2', weight: 9 }, // Much higher weight
            ];
            // Run multiple times to test distribution
            const counts = { var_1: 0, var_2: 0 };
            const iterations = 1000;
            for (let i = 0; i < iterations; i++) {
                const result = resolver.weightedRandom(variants);
                counts[result.variant_id]++;
            }
            // var_2 should be selected ~90% of the time
            expect(counts.var_2).toBeGreaterThan(counts.var_1 * 5);
        });
        it('should handle zero weights', () => {
            const variants = [
                { variant_id: 'var_1', weight: 0 },
                { variant_id: 'var_2', weight: 0 },
            ];
            // Should still return a variant (random selection)
            const result = resolver.weightedRandom(variants);
            expect(['var_1', 'var_2']).toContain(result.variant_id);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2dyb3Zlci5oZWVyL0RvY3VtZW50cy9HaXRIdWIvQWR2aXRpeWFfSC9zcmMvX190ZXN0c19fL1ZhcmlhbnRSZXNvbHZlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBSUEsdUJBQXVCO0FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNsQyxPQUFPLEVBQUU7UUFDTCxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNmLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ3JCO0NBQ0osQ0FBQyxDQUFDLENBQUM7QUFFSixJQUFJLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdkMsWUFBWSxFQUFFO1FBQ1YsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7S0FDbEI7Q0FDSixDQUFDLENBQUMsQ0FBQztBQWhCSixpRUFBOEQ7QUFrQjlELCtDQUE0QztBQUM1Qyx5REFBc0Q7QUFFdEQsUUFBUSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtJQUM3QixJQUFJLFFBQXlCLENBQUM7SUFFOUIsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNaLFFBQVEsR0FBRyxJQUFJLGlDQUFlLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDekIsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFO1FBQzVCLEVBQUUsQ0FBQywyQ0FBMkMsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN2RCxNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzVELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM5QixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxtREFBbUQsRUFBRSxLQUFLLElBQUksRUFBRTtZ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QUUsQ0FBQyxFQUFFO2dCQUNsQyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRTthQUN2QixDQUFDO1lBRWhCLG1EQUFtRDtZQUNuRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDNUQsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ncm92ZXIuaGVlci9Eb2N1bWVudHMvR2l0SHViL0Fkdml0aXlhX0gvc3JjL19fdGVzdHNfXy9WYXJpYW50UmVzb2x2ZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWYXJpYW50UmVzb2x2ZXIgfSBmcm9tICcuLi9zZXJ2aWNlcy9WYXJpYW50UmVzb2x2ZXInO1xuaW1wb3J0IHsgSVZhcmlhbnQgfSBmcm9tICcuLi9tb2RlbHMvVmFyaWFudCc7XG5pbXBvcnQgeyBJVmFyaWFudFN0YXRzIH0gZnJvbSAnLi4vbW9kZWxzL1ZhcmlhbnRTdGF0cyc7XG5cbi8vIE1vY2sgbW9uZ29vc2UgbW9kZWxzXG5qZXN0Lm1vY2soJy4uL21vZGVscy9WYXJpYW50JywgKCkgPT4gKHtcbiAgICBWYXJpYW50OiB7XG4gICAgICAgIGZpbmQ6IGplc3QuZm4oKSxcbiAgICAgICAgZmluZE9uZTogamVzdC5mbigpLFxuICAgIH0sXG59KSk7XG5cbmplc3QubW9jaygnLi4vbW9kZWxzL1ZhcmlhbnRTdGF0cycsICgpID0+ICh7XG4gICAgVmFyaWFudFN0YXRzOiB7XG4gICAgICAgIGZpbmQ6IGplc3QuZm4oKSxcbiAgICB9LFxufSkpO1xuXG5pbXBvcnQgeyBWYXJpYW50IH0gZnJvbSAnLi4vbW9kZWxzL1ZhcmlhbnQnO1xuaW1wb3J0IHsgVmFyaWFudFN0YXRzIH0gZnJvbSAnLi4vbW9kZWxzL1ZhcmlhbnRTdGF0cyc7XG5cbmRlc2NyaWJlKCdWYXJpYW50UmVzb2x2ZXInLCAoKSA9PiB7XG4gICAgbGV0IHJlc29sdmVyOiBWYXJpYW50UmVzb2x2ZXI7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZXIgPSBuZXcgVmFyaWFudFJlc29sdmVyKCk7XG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3Jlc29sdmVWYXJpYW50JywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBlbXB0eSB2YXJpYW50IGxpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvbHZlci5yZXNvbHZlVmFyaWFudChbXSwgJ2h1Yl8wMDEnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHZhcmlhbnQgZGlyZWN0bHkgaWYgb25seSBvbmUgb3B0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja1ZhcmlhbnQgPSB7XG4gICAgICAgICAgICAgICAgdmFyaWFudF9pZDogJ3Zhcl8xJyxcbiAgICAgICAgICAgICAgICBodWJfaWQ6ICdodWJfMDAxJyxcbiAgICAgICAgICAgICAgICB0YXJnZXRfdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDEwLFxuICAgICAgICAgICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgfSBhcyBJVmFyaWFudDtcblxuICAgICAgICAgICAgKFZhcmlhbnQuZmluZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKFttb2NrVmFyaWFudF0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvbHZlci5yZXNvbHZlVmFyaWFudChbJ3Zhcl8xJ10sICdodWJfMDAxJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tWYXJpYW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBzZWxlY3QgdmFyaWFudCB3aXRoIGhpZ2hlc3Qgc2NvcmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYW50cyA9IFtcbiAgICAgICAgICAgICAgICB7IHZhcmlhbnRfaWQ6ICd2YXJfMScsIGh1Yl9pZDogJ2h1Yl8wMDEnLCB0YXJnZXRfdXJsOiAndXJsMScsIHByaW9yaXR5OiA1LCB3ZWlnaHQ6IDEgfSxcbiAgICAgICAgICAgICAgICB7IHZhcmlhbnRfaWQ6ICd2YXJfMicsIGh1Yl9pZDogJ2h1Yl8wMDEnLCB0YXJnZXRfdXJsOiAndXJsMicsIHByaW9yaXR5OiA1LCB3ZWlnaHQ6IDEgfSxcbiAgICAgICAgICAgIF0gYXMgSVZhcmlhbnRbXTtcblxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBbXG4gICAgICAgICAgICAgICAgeyB2YXJpYW50X2lkOiAndmFyXzEnLCBodWJfaWQ6ICdodWJfMDAxJywgc2NvcmU6IDAuNSB9LFxuICAgICAgICAgICAgICAgIHsgdmFyaWFudF9pZDogJ3Zhcl8yJywgaHViX2lkOiAnaHViXzAwMScsIHNjb3JlOiAwLjggfSwgLy8gSGlnaGVyIHNjb3JlXG4gICAgICAgICAgICBdIGFzIElWYXJpYW50U3RhdHNbXTtcblxuICAgICAgICAgICAgKFZhcmlhbnQuZmluZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHZhcmlhbnRzKTtcbiAgICAgICAgICAgIChWYXJpYW50U3RhdHMuZmluZCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKHN0YXRzKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzb2x2ZXIucmVzb2x2ZVZhcmlhbnQoWyd2YXJfMScsICd2YXJfMiddLCAnaHViXzAwMScpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdD8udmFyaWFudF9pZCkudG9CZSgndmFyXzInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBicmVhayB0aWVzIHVzaW5nIHByaW9yaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudHMgPSBbXG4gICAgICAgICAgICAgICAgeyB2YXJpYW50X2lkOiAndmFyXzEnLCBodWJfaWQ6ICdodWJfMDAxJywgdGFyZ2V0X3VybDogJ3VybDEnLCBwcmlvcml0eTogNSwgd2VpZ2h0OiAxIH0sXG4gICAgICAgICAgICAgICAgeyB2YXJpYW50X2lkOiAndmFyXzInLCBodWJfaWQ6ICdodWJfMDAxJywgdGFyZ2V0X3VybDogJ3VybDInLCBwcmlvcml0eTogMTAsIHdlaWdodDogMSB9LCAvLyBIaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIF0gYXMgSVZhcmlhbnRbXTtcblxuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBbXG4gICAgICAgICAgICAgICAgeyB2YXJpYW50X2lkOiAndmFyXzEnLCBodWJfaWQ6ICdodWJfMDAxJywgc2NvcmU6IDAuNSB9LFxuICAgICAgICAgICAgICAgIHsgdmFyaWFudF9pZDogJ3Zhcl8yJywgaHViX2lkOiAnaHViXzAwMScsIHNjb3JlOiAwLjUgfSwgLy8gU2FtZSBzY29yZVxuICAgICAgICAgICAgXSBhcyBJVmFyaWFudFN0YXRzW107XG5cbiAgICAgICAgICAgIChWYXJpYW50LmZpbmQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh2YXJpYW50cyk7XG4gICAgICAgICAgICAoVmFyaWFudFN0YXRzLmZpbmQgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShzdGF0cyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc29sdmVyLnJlc29sdmVWYXJpYW50KFsndmFyXzEnLCAndmFyXzInXSwgJ2h1Yl8wMDEnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQ/LnZhcmlhbnRfaWQpLnRvQmUoJ3Zhcl8yJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3dlaWdodGVkUmFuZG9tJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIHNlbGVjdCBmcm9tIHZhcmlhbnRzIGJhc2VkIG9uIHdlaWdodCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRzID0gW1xuICAgICAgICAgICAgICAgIHsgdmFyaWFudF9pZDogJ3Zhcl8xJywgd2VpZ2h0OiAxIH0sXG4gICAgICAgICAgICAgICAgeyB2YXJpYW50X2lkOiAndmFyXzInLCB3ZWlnaHQ6IDkgfSwgLy8gTXVjaCBoaWdoZXIgd2VpZ2h0XG4gICAgICAgICAgICBdIGFzIElWYXJpYW50W107XG5cbiAgICAgICAgICAgIC8vIFJ1biBtdWx0aXBsZSB0aW1lcyB0byB0ZXN0IGRpc3RyaWJ1dGlvblxuICAgICAgICAgICAgY29uc3QgY291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0geyB2YXJfMTogMCwgdmFyXzI6IDAgfTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGlvbnMgPSAxMDAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVyLndlaWdodGVkUmFuZG9tKHZhcmlhbnRzKTtcbiAgICAgICAgICAgICAgICBjb3VudHNbcmVzdWx0LnZhcmlhbnRfaWRdKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhcl8yIHNob3VsZCBiZSBzZWxlY3RlZCB+OTAlIG9mIHRoZSB0aW1lXG4gICAgICAgICAgICBleHBlY3QoY291bnRzLnZhcl8yKS50b0JlR3JlYXRlclRoYW4oY291bnRzLnZhcl8xICogNSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHplcm8gd2VpZ2h0cycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRzID0gW1xuICAgICAgICAgICAgICAgIHsgdmFyaWFudF9pZDogJ3Zhcl8xJywgd2VpZ2h0OiAwIH0sXG4gICAgICAgICAgICAgICAgeyB2YXJpYW50X2lkOiAndmFyXzInLCB3ZWlnaHQ6IDAgfSxcbiAgICAgICAgICAgIF0gYXMgSVZhcmlhbnRbXTtcblxuICAgICAgICAgICAgLy8gU2hvdWxkIHN0aWxsIHJldHVybiBhIHZhcmlhbnQgKHJhbmRvbSBzZWxlY3Rpb24pXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlci53ZWlnaHRlZFJhbmRvbSh2YXJpYW50cyk7XG4gICAgICAgICAgICBleHBlY3QoWyd2YXJfMScsICd2YXJfMiddKS50b0NvbnRhaW4ocmVzdWx0LnZhcmlhbnRfaWQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9