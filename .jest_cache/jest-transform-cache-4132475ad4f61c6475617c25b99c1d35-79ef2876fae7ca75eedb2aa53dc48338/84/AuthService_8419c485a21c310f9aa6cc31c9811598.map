{"file":"/Users/grover.heer/Documents/GitHub/Advitiya_H/src/services/AuthService.ts","mappings":"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","names":[],"sources":["/Users/grover.heer/Documents/GitHub/Advitiya_H/src/services/AuthService.ts"],"sourcesContent":["import jwt from 'jsonwebtoken';\nimport { v4 as uuidv4 } from 'uuid';\nimport { User, IUser, hashPassword, UserRole } from '../models/User';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'smart-link-hub-secret-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\n\n/**\n * JWT Payload structure\n */\nexport interface IJWTPayload {\n    user_id: string;\n    email: string;\n    role: UserRole;\n}\n\n/**\n * Auth result returned after successful login/register\n */\nexport interface IAuthResult {\n    user: {\n        user_id: string;\n        email: string;\n        name?: string;\n        role: UserRole;\n    };\n    token: string;\n    expires_in: string;\n}\n\n/**\n * Authentication Service\n * Handles user registration, login, and JWT token management\n */\nexport class AuthService {\n\n    /**\n     * Register a new user\n     */\n    async register(email: string, password: string, name?: string, role?: UserRole): Promise<IAuthResult> {\n        // Check if email already exists\n        const existing = await User.findOne({ email: email.toLowerCase() });\n        if (existing) {\n            throw new Error('Email already registered');\n        }\n\n        // Validate password strength\n        if (password.length < 8) {\n            throw new Error('Password must be at least 8 characters');\n        }\n\n        // Hash password\n        const password_hash = await hashPassword(password);\n\n        // Create user\n        const user = await User.create({\n            user_id: uuidv4(),\n            email: email.toLowerCase(),\n            password_hash,\n            name,\n            role: role || 'user',\n        });\n\n        // Generate token\n        const token = this.generateToken(user);\n\n        return {\n            user: {\n                user_id: user.user_id,\n                email: user.email,\n                name: user.name,\n                role: user.role,\n            },\n            token,\n            expires_in: JWT_EXPIRES_IN,\n        };\n    }\n\n    /**\n     * Login with email and password\n     */\n    async login(email: string, password: string): Promise<IAuthResult> {\n        // Find user with password\n        const user = await User.findOne({ email: email.toLowerCase() })\n            .select('+password_hash');\n\n        if (!user) {\n            throw new Error('Invalid email or password');\n        }\n\n        // Compare passwords\n        const isMatch = await user.comparePassword(password);\n        if (!isMatch) {\n            throw new Error('Invalid email or password');\n        }\n\n        // Generate token\n        const token = this.generateToken(user);\n\n        return {\n            user: {\n                user_id: user.user_id,\n                email: user.email,\n                name: user.name,\n                role: user.role,\n            },\n            token,\n            expires_in: JWT_EXPIRES_IN,\n        };\n    }\n\n    /**\n     * Verify a JWT token and return the payload\n     */\n    verifyToken(token: string): IJWTPayload {\n        try {\n            const payload = jwt.verify(token, JWT_SECRET) as IJWTPayload;\n            return payload;\n        } catch (error) {\n            throw new Error('Invalid or expired token');\n        }\n    }\n\n    /**\n     * Generate a JWT token for a user\n     */\n    private generateToken(user: IUser): string {\n        const payload: IJWTPayload = {\n            user_id: user.user_id,\n            email: user.email,\n            role: user.role,\n        };\n\n        // Convert expiry to seconds (7 days default)\n        const expiresInSeconds = this.parseExpiryToSeconds(JWT_EXPIRES_IN);\n\n        return jwt.sign(payload, JWT_SECRET, {\n            expiresIn: expiresInSeconds,\n        });\n    }\n\n    /**\n     * Parse expiry string to seconds\n     */\n    private parseExpiryToSeconds(expiry: string): number {\n        const match = expiry.match(/^(\\d+)([smhd])$/);\n        if (!match) {\n            return 7 * 24 * 60 * 60; // Default: 7 days\n        }\n        const value = parseInt(match[1], 10);\n        const unit = match[2];\n        switch (unit) {\n            case 's': return value;\n            case 'm': return value * 60;\n            case 'h': return value * 60 * 60;\n            case 'd': return value * 24 * 60 * 60;\n            default: return 7 * 24 * 60 * 60;\n        }\n    }\n\n    /**\n     * Get user by ID\n     */\n    async getUserById(userId: string): Promise<IUser | null> {\n        return User.findOne({ user_id: userId });\n    }\n\n    /**\n     * Get user by email\n     */\n    async getUserByEmail(email: string): Promise<IUser | null> {\n        return User.findOne({ email: email.toLowerCase() });\n    }\n\n    /**\n     * Check if a user is admin\n     */\n    isAdmin(user: IUser | IJWTPayload): boolean {\n        return user.role === 'admin';\n    }\n}\n\n// Singleton instance\nexport const authService = new AuthService();\n"],"version":3}